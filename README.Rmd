---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->




```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```


<!-- badges: start -->
<!-- badges: end -->

<!-- Logo -->
<p align="center">
  <img src="man/figures/logo.png" width="300">
</p>

`dedaptive` provides tools for **DEcision-oriented aDAPTIVE testing** based on  
**multidimensional item response theory (IRT)**.  The framework is described in Wyss et al. (2025). 

To install the development version, you need the package `remotes`. The package `dedaptive`can be installed with `remotes::install_github("Statric/dedaptive")`


This workflow demonstrates:

1. Loading the data set integrated in the package and preparing training and prediction data sets  
3. Fitting a multidimensional IRT model (`fitIrt`) 
4. Simulation-based predictions of joint item distributions (`predJointDistRespIrt`)
5. Performing probabilistic predictions with fixed-item panels (`fixSelectionIrt`) and adaptive, decision-oriented and cost-sensitive testing (`dedaptiveIrt`)
6. Simulating new item responses given predictor values (`simResponsesIrt`)  

## 1. Load and prepare the example data

We load the `dedaptive` library and then the included data set `screenMental`

```{r}
library(dedaptive)
data(screenMental)
head(screenMental, 3)
```



The dataset `screenMental` is a fully simulated data set that mimics PHQ-9 and GAD-7 item responses observed in a real sample. Simulations were based on models trained on the original data set used in the publication of Wyss et al. (2025). The exact procedure for the data generation is described in the section 5 (*Simulate a data set*) below. The data set contains sex and age as well as 16 item responses: the nine items of the Patient Health Questionnaire-9 (PHQ-9) and the seven items of the Generalized Anxiety Disorder-7 (GAD-7) scale.


In the following examples, we are interested in the joint distribution of the PHQ-9 and GAD-7 sum scores and the corresponding binary decisions, defined as PHQ-9 sum score $\geq 10$ and GAD-7 sum score $\geq 10$ (moderate to severe symptoms). To this end, we first define functions to compute the sum scores and specify the thresholds for these decisions:

```{r}
# Extract PHQ-9 and GAD-7 items
itemsPhq<- colnames(screenMental)[grepl("phq", colnames(screenMental))]
itemsGad<- colnames(screenMental)[grepl("gad", colnames(screenMental))]
itemsAll<- c(itemsPhq, itemsGad)

# Score functions
funSumScores <- list(
  function(x) sum(x[1:9]),   # PHQ-9 sum
  function(x) sum(x[10:16])    # GAD-7 sum
)

# Thresholds
thresModSev <- c(10, 10)

# Add scores and decisions to the data set
screenMental$phq_score<- apply(screenMental[, itemsAll], 1, funSumScores[[1]])
screenMental$gad_score<- apply(screenMental[, itemsAll], 1, funSumScores[[2]])

screenMental$phq_dec<- ifelse(screenMental$phq_score>=thresModSev[1], 1, 0)
screenMental$gad_dec<- ifelse(screenMental$gad_score>=thresModSev[2], 1, 0)
```

We standardize the age and prepare train and prediction (one person) sets
```{r}
screenMental$ageStand<- (screenMental$age-mean(screenMental$age))/sd(screenMental$age)

#screenMental[which(screenMental$phq_score==10 & screenMental$gad_score==8), ]
idPred<- 249
screenMental[screenMental$id==idPred, ]

dataTrain <- screenMental[screenMental$id != idPred, ]
dataSub   <- screenMental[screenMental$id == idPred, ]
```

To illustrate the predictions we chose a female, 35 years old person with a PHQ-9 sum score of 10 and a GAD-7 sum score of 8. 

## 2. Fit a multidimensional IRT model

With the function `fitIrt`, multidimensional IRT models can be fitted. The function is a wrapper around `mirt::mirt` from the `mirt` package, but tailored to the requirements of `dedaptive`. In particular, if an IRT model is to be used for probabilistic predictions or adaptive item selection with `dedaptive` (e.g., via `predJointDistRespIrt`, `fixSelectionIrt`, or `dedaptiveIrt`), it has to be fitted using `fitIrt`.

Via the argument `model`, we can specify the latent structure, for example the number of latent variables, which items load on which latent variables, and whether latent variables are correlated. In the example below, we consider two independent latent variables and assume that all items load on both latent variables. This **2-factor model** is specified in the object `whichLatentStructure`. Moreover, we assume that the latent variables depend on sex and age via a latent regression, specified by the formula `whichFormula`.

This **2-factor model** can be fitted as follows: 

```{r}
# Two-factor model specification
whichLatentStructure <- mirt::mirt.model("
  F1 = 1-16
  F2 = 1-16
")

# Latent regression formula (right-hand side only)
whichFormula <- "ageStand + sex"

# Fit the model
modelTrain <- fitIrt(
  model    = whichLatentStructure,
  respName = itemsAll,
  formula  = whichFormula,
  data     = dataTrain
)
```

The IRT model itself is saved in *modelTrain$fit*. We can inspect the loadings and regression:

```{r}
# loadings
summary(modelTrain$fit)

#latent regression
coef(modelTrain$fit)$lr.betas
```

For more details, see the help page of the function (`?fitIrt`) and the documentation of the function `mirt`. 


## 3. Approximate joint item distributions

The function `predJointDistRespIrt` performs probabilistic predictions of item responses based on an IRT model fitted with `fitIrt`. The method can incorporate predictors via a latent regression (if specified) and can optionally condition on already observed responses for a subset of items. Predictions are obtained using a two-step Monte Carlo scheme with `nSimTheta` simulations of latent variables and `nSimItem` simulated response patterns for each draw of the latent variables, resulting in `nSimTheta * nSimItem` simulated response patterns in total. More details on this approximation strategy can be found in Wyss et al. (2025).

### Prior predictions

We first illustrate the function for the held-out individual in `dataSub`, assuming that no item responses are known (i.e., prior predictions):

```{r}
set.seed(123)
predJointPrior <- predJointDistRespIrt(
  model     = modelTrain,
  dataSub   = dataSub,
  nSimTheta = 10000,
  nSimItem  = 10,
  seed      = 123
)
head(predJointPrior$jointDist, 3)
```
The object predJointPrior contains

- a table with all `nSimTheta * nSimItem` simulated response patterns (`predJointPrior$sim`), and

- a table with the relative frequencies of unique response patterns (`predJointPrior$jointDist`).

These prior distributions summarize the uncertainty about all item responses given only the predictors (sex and age) and the fitted IRT model.

### Conditional predictions

The function can also be used to predict distributions conditional on known responses for a subset of items. Below, we perform predictions for the same held-out individual under two different response patterns for the first PHQ and GAD items:

- phq1 = 1, gad1 = 1 

- phq1 = 3, gad1 = 0

```{r}
set.seed(123)

# Define the given responses
resp1<- c(phq1=1, gad1=1)
resp2<- c(phq1=3, gad1=0)

# Perform probabilistic predictions
predJointCond1<- predJointDistRespIrt(modelTrain, dataSub, 
                                      nSimTheta=10000, nSimItem=10, 
                                      givenVal=resp1)
predJointCond2<- predJointDistRespIrt(modelTrain, dataSub, 
                                      nSimTheta=10000, nSimItem=10,
                                      givenVal=resp2)
```

In addition to the simulated response patterns and their relative frequencies (as in `predJointPrior`), the conditional predictions also include an approximate posterior distribution of the latent variables in `postDistTheta`:

```{r, fig.width=7, fig.height=4, fig.cap="Fig. 1 posterior distribution of latent variables"}
par(mfrow=c(2,2), mar=c(4,4,2,1))

plot(predJointCond1$postDistTheta$dist[,1],
     predJointCond1$postDistTheta$dist[,3],
     type="h", lwd=2, xlab="F1", ylab="Freq",
     main="F1 | phq1=1, gad1=1")

plot(predJointCond1$postDistTheta$dist[,2],
     predJointCond1$postDistTheta$dist[,3],
     type="h", lwd=2, xlab="F2", ylab="Freq",
     main="F2 | phq1=1, gad1=1")

plot(predJointCond2$postDistTheta$dist[,1],
     predJointCond2$postDistTheta$dist[,3],
     type="h", lwd=2, xlab="F1", ylab="Freq",
     main="F1 | phq1=3, gad1=0")

plot(predJointCond2$postDistTheta$dist[,2],
     predJointCond2$postDistTheta$dist[,3],
     type="h", lwd=2, xlab="F2", ylab="Freq",
     main="F2 | phq1=3, gad1=0")
```

These plots visualize how the posterior distributions of the latent variables shift when different item responses are observed. Sm

## 4. Fixed and dedaptive item selections

With the function `fixSelectionIrt`, probabilistic predictions can be performed for an individual based on known responses to a **fixed subset** of items.

With the function `dedaptiveIrt`, items are **adaptively selected** and their responses are dynamically incorporated into the probabilistic predictions. The function also returns predictions based on the final, individualized set of selected items.

Both functions provide probabilistic predictions for

1. the latent variables (`distTheta`),

2. the score functions (e.g., PHQ-9 and GAD-7 sum scores in this example) and the corresponding binary decisions (e.g., PHQ-9 / GAD-7 sum score $\geq 10$; `distFun`), and  

3. the response patterns of the remaining items (`distItems`).  

Note that both functions assume that all item responses are available for the held-out individual so that “true” scores and decisions can be computed and compared with the probabilistic predictions.

We first illustrate `fixSelectionIrt` for the individual in `dataSub`, using only the item responses of the short forms PHQ-2 and GAD-2 to perform probabilistic predictions:


```{r}
# Define items for which the responses are used for predictions
itemsShortVersion <- c("phq1", "phq2", "gad1", "gad2")

# Show the responses
dataSub[, itemsShortVersion]

# Perform predictions
predShortVersion <- fixSelectionIrt(
  model      = modelTrain,
  dataSub    = dataSub,
  thres      = thresModSev,
  funOfItems = funSumScores,
  givenVar   = itemsShortVersion,
  nSimTheta  = 10000,
  nSimItem   = 10,
  seed       = 13
)

```

The object `predShortVersion$pred` contains a summary of the predictions (e.g., predicted and true scores, predicted class probabilities, and true decisions). The component `predShortVersion$distFun` stores the approximated joint distribution of the scores and corresponding decisions. 

We now perform the same steps with the function `dedaptiveIrt`, which automatically selects items to optimize the considered decisions. For dedaptive testing, we have to specify cost parameters via the argument `costs`, that is, costs for false-positive (FP) and false-negative (FN) classifications for each decision, as well as measurement costs per item.

```{r}
# Define cost parameters
prescribedCosts<- list(c(0.5, 0.5), # costs FP for every decision
                       c(0.5, 0.5), # costs FN for everyl decision
                       0.05) # measurement costs of one item)
# Perform dedaptive selections and predictions
predDedaptive <- dedaptiveIrt(
  model      = modelTrain,
  dataSub    = dataSub,
  thres      = thresModSev,
  funOfItems = funSumScores,
  costs      = prescribedCosts,
  nSimTheta  = 10000,
  nSimItem   = 10,
  seed       = 13
)
```



For two scores and two decisions, these probabilistic predictions can be visualized with the function `plotScoresItemSelection` based on `predShortVersion$distFun`:

```{r, fig.width=7,fig.height=7, fig.cap="Fig. 2 posterior distribution of the scores with fixed item selection (phq1=1, phq2=1, gad1=3, gad2=1)"}
# Plot the results
plotScoresItemSelection(predShortVersion, main="", xlab="PHQ-9 sum score (Score 1)", 
                        ylab="GAD-7 sum score (Score 2)")
# Show summary predictions
predShortVersion$pred
```
```{r, fig.width=7,fig.height=7, fig.cap="Fig. 3 posterior distribution of the scores with dedaptive item selection (gad2=1, phq4=2, phq5=1, phq6=3)"}
# Plot the results
plotScoresItemSelection(predDedaptive, main="", xlab="PHQ-9 sum score (Score 1)", 
                        ylab="GAD-7 sum score (Score 2)")
# Show summary predictions
predDedaptive$pred[, 1:8]

# Show the responses of the selected items
dataSub[, predDedaptive$chosen, drop=F]
```
In the fixed item selection (phq1 = 1, phq2 = 1, gad1 = 3, gad2 = 1), the central panel in **Fig. 1**  shows the predicted joint distribution of PHQ-9 (Score 1, x-axis) and GAD-7 (Score 2, y-axis) sum scores based on the PHQ-2 and GAD-2 item responses. Each dot represents a possible score combination, with larger, greener dots indicating higher probability. The blue dashed lines mark the clinical thresholds at a sum score of 10. The estimated decision probabilities are  
$\(P(\text{Score 1} \ge 10) = 0.434\)$ and $\(P(\text{Score 2} \ge 10) = 0.424\)$. The probability mass is fairly diffuse around both thresholds. The grey marginal barplots on the top and right show the corresponding marginal distributions for each score separately. With the fixed item selections, the individual is falsely classified as PHQ-9 $\leq$ 10 and correctly classified as GAD $\gep$ 10. 

In the dedaptive selection , the same type of plot is shown after four adaptively chosen items (gad2 = 1, phq4 = 2, phq5 = 1, phq6 = 3). Here, the predictive distribution is more concentrated around PHQ-9 scores $\geq$ 10 and GAD-7 scores $\les$ 10. The estimated decision probabilities are  
$\(P(\text{Score 1} \ge 10) = 0.908\)$ and $\(P(\text{Score 2} \ge 10) = 0.307\)$. Thus, for the same number of administered items, dedaptive yields a much more decisive prediction for PHQ-9 (probability close to 1 instead of about 0.5), while keeping the GAD-7 decision more clearly below the threshold. With the fixed item selections, both classifications are correct for the considered individual. 


## 5. Simulate a data set

The function `simResponsesIrt` can be used to simulate item responses based on predictor variables from the latent regression and a trained IRT model (fitted with `fitIrt` and used within `predJointDistRespIrt`). This function was originally used to generate the data set `screenMental` in the `dedaptive` package from a dataset with item responses of real individuals. In the following, we apply the same procedure to generate a new simulated data set based on `screenMental`.

First, we fit a multidimensional IRT model to the full `screenMental` data set (using the same model structure as in Section 2):

```{r}
# Fit the model
modelAllData <- fitIrt(
  model    = whichLatentStructure,
  respName = itemsAll,
  formula  = whichFormula,
  data     = screenMental
)
```

Given this model, we can generate example response patterns for specified predictor values, for instance:

```{r}
# woman with age mean-1SD, man with age mean+1SD
simResponsesIrt(modelAllData, data.frame(ageStand=c(-1, 1), sex=c(1, 0)))
```


Our goal, however, is to create an entire data set that reflects the same relationships between variables as in `screenMental`, without re-using any real observations (including age and sex). To this end, we first simulate new values for sex and age. We estimate

- the marginal distribution of sex, and

- sex-specific kernel densities of age (age conditional on sex)

from `screenMental`, and then simulate first sex and then the age given the sex from these estimated distributions. This is implemented in the function `simulateSexAge` below (not integrated in the package `dedaptive`):

```{r}
simulateSexAge <- function(data, nSim,
                           sexVar = "sex",
                           ageVar = "age", ...) {
  # 1) Prepare 
  sex <- data[[sexVar]]
  age <- data[[ageVar]]
  
  # Remove missing
  okCases <- stats::complete.cases(sex, age)
  sex <- sex[okCases]
  age <- age[okCases]
  
  # 2) Estimate distribution P(sex), f(age | sex)
  
  # Marginal distribution of sex
  sexTab  <- table(sex)
  sexProb <- prop.table(sexTab)
  sexVals <- sort(unique(sex))
  
  # Kernel densities for age within each sex
  densityList <- lapply(sexVals, function(s) {
    stats::density(age[sex == s], ...)
  })
  #names(densityList) <- sexVals
  
  # helper: sample from a 1D kernel density estimate
  sampleFromDensity <- function(d, n) {
    cdf <- cumsum(d$y)
    cdf <- cdf / max(cdf)
    u <- stats::runif(n)
    idx <- findInterval(u, vec = c(0, cdf), rightmost.closed = TRUE)
    d$x[pmax(1, idx)]
  }
  
  # 3) Simulate from estimated joint distribution
  # Simulate sex from its marginal
  simSexChar <- sample(sexVals, size = nSim, replace = TRUE, prob = sexProb)
  
  # Simulate age conditional on sex
  simAge <- numeric(nSim)
  for (s in 1:length(sexVals)) {
    idx <- which(simSexChar == sexVals[s])
    if (length(idx) > 0) {
      simAge[idx] <- sampleFromDensity(densityList[[s]], length(idx))
    }
  }
  
  simData <- data.frame(
    sex = simSexChar,
    age = simAge
  )
  
  # Return simulations plus estimated components
  list(
    sim = simData,
    sexProb = sexProb,
    ageDensities = densityList
  )
}
```

We first generate a data set with simulated sex and age values:

```{r}
# Apply the function simulateSexAge
# (includes distribution estimates besides the simulated data)
listSim<- simulateSexAge(screenMental, nrow(screenMental), "sex", "age")

# Extract simulated data
dataSim<- listSim$sim

# Round the age to a resolution of one year
dataSim$age<- round(dataSim$age)

# Show first rows
head(dataSim, 3)
```

Given these predictor values, we can now simulate item responses with `simResponsesIrt`. We first re-scale age using the mean and standard deviation from `screenMental`:

```{r}
# Standardize the age (mean and SD from screenMental)
dataSim$ageStand<- (dataSim$age-mean(screenMental$age))/sd(screenMental$age)

# Simulate response patterns given sex and age
dataSim<- simResponsesIrt(modelAllData, dataSim, seed=13)

# Remove standardized age 
dataSim$ageStand<- NULL

head(dataSim,3)
```

The resulting object `dataSim` is a new, fully simulated data set with sex, age, and PHQ-9/GAD-7 item responses that follow the dependency structure learned from `screenMental`, but without containing any original individual-level records.
